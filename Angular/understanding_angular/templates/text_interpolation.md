# 'Text interpolation' {angular}

[https://angular.io/guide/interpolation](https://angular.io/guide/interpolation)

November 20, 2021 

Текстовая интерполяция позволяет включать динамические строковые значения в шаблоны HTML. Используйте интерполяцию для динамического изменения того, что появляется в представлении приложения, например, для отображения пользовательского приветствия, включающего имя пользователя.

> Смотрите [живой пример](https://angular.io/generated/live-examples/interpolation/stackblitz.html) / [пример для скачивания](https://angular.io/generated/zips/interpolation/interpolation.zip) для всего синтаксиса и фрагментов кода в этом руководстве.
> 

# **Отображение значений с помощью интерполяции**

Интерполяция - это вставка выражений в размеченный текст. По умолчанию интерполяция использует двойные фигурные скобки `{{` и `}}` в качестве разделителей.

Чтобы проиллюстрировать работу интерполяции, рассмотрим компонент Angular, содержащий переменную `currentCustomer`:

```tsx
currentCustomer = 'Maria';
```

Используем интерполяцию для отображения значения этой переменной в соответствующем шаблоне компонента:

```html
<h3>Current customer: {{ currentCustomer }}</h3>
```

Angular заменяет `currentCustomer` строковым значением соответствующего свойства компонента. В данном случае это значение равно `Maria`.

В следующем примере Angular обрабатывает свойства `title` и `itemImageUrl` для отображения текста заголовка и изображения.

```html
<p>{{title}}</p>
<div><img src="{{itemImageUrl}}"></div>
```

# **Template expressions (шаблон-выражения)**

**Шаблон-выражение [template expression {angular}](https://www.notion.so/template-expression-angular-6ebb293e4f634a14a6f324c1b9786889)** дает значение и находится в двойных фигурных скобках, `{{ }}`. Angular разрешает выражение и присваивает его свойству целевой привязки. Целью может быть HTML-элемент, компонент или директива.

## = **Выполнение выражений с помощью интерполяции**.

В общем случае текст между скобками - это шаблон-выражение, которое Angular сначала вычисляет, а затем преобразует в строку. Следующая интерполяция иллюстрирует этот момент, складывая два числа:

```html
<!-- "сумма 1 + 1 это 2" -->
<p>The sum of 1 + 1 is {{1 + 1}}.</p>
```

Выражения также могут вызывать методы хост-компонента, как `getVal()` в следующем примере:

```html
<!-- "The sum of 1 + 1 is not 4" -->
<p>The sum of 1 + 1 is not {{1 + 1 + getVal()}}.</p>
```

С помощью интерполяции Angular выполняет следующие задачи:

1. Вычисляет все выражения в двойных фигурных скобках.
2. Преобразует результаты выражения в строки.
3. Связывает результаты с любыми соседними литеральными строками.
4. Присваивает композит элементу или свойству директивы.

> Настраивайте разделитель интерполяции с помощью опции [interpolation](https://angular.io/api/core/Component#interpolation) в метаданных @[Component](https://angular.io/api/core/Component)().
> 

## = Синтаксис

Шаблон-выражения аналогичны выражениям JavaScript. Многие выражения JavaScript являются допустимыми шаблон-выражениями, за следующими исключениями.

Вы не можете использовать выражения JavaScript, которые имеют или способствуют появлению побочных эффектов, включая:

- Присваивания (`=`, `+=`, `=`, `...`).
- Операторы, такие как `new`, `typeof` или `instanceof`.
- Цепочки выражений с `;` или `,`.
- Операторы инкремента и декремента `++` и `-`.
- Некоторые из операторов ES2015+

Другие заметные отличия от синтаксиса JavaScript включают:

- Отсутствие поддержки побитовых операторов, таких как `|` и `&`.
- Новые [операторы шаблонных выражений](https://angular.io/guide/template-expression-operators), такие как `|`, `?.` и `!`.

# Контекст выражений

Интерполированные выражения имеют контекст - определенную часть приложения, к которой принадлежит выражение. Как правило, таким контекстом является экземпляр компонента.

В следующем фрагменте выражение `recommended` и выражение `itemImageUrl2` относятся к свойствам `AppComponent`.

```html
<h4>{{recommended}}</h4>
<img [src]="itemImageUrl2">
```

Выражение также может ссылаться на свойства контекста *шаблона*, такие как [входная переменная шаблона](https://angular.io/guide/structural-directives#shorthand) или [template reference variable](https://angular.io/guide/template-reference-variables).

В следующем примере используется входная переменная шаблона `customer`.

```html
<ul>
  <li *ngFor="let customer of customers">{{customer.name}}</li>
</ul>
```

В следующем примере используется ссылочная переменная шаблона `#customerInput`.

```html
<label>Type something:
  <input #customerInput>{{customerInput.value}}>
</label>
```

Шаблон-выражения не могут ссылаться ни на что в глобальном пространстве имен, кроме `undefined`. Они не могут ссылаться на `window` или `document`. Кроме того, они не могут вызывать `console.log()` или `Math.max()` и ограничены ссылками на члены контекста выражения.

## = Разрешение конфликтов имён

Контекст, относительно которого вычисляется выражение, является объединением переменных шаблона, контекстного объекта директивы - если он есть - и членов компонента. Если вы ссылаетесь на имя, принадлежащее более чем одному из этих пространств имен, Angular применяет следующую логику для определения контекста:

1. Имя переменной шаблона.
2. Имя в контексте директивы.
3. Имена членов компонента.

Чтобы переменные не затеняли переменные в другом контексте, сохраняйте уникальность имен переменных. В следующем примере шаблон `AppComponent` приветствует `customer`, Padma.

Затем [ngFor](https://angular.io/api/common/NgForOf) перечисляет каждого `customer` в массиве `customers`.

```tsx
@Component({
  template: `
    <div>
      <!-- Hello, Padma -->
      <h1>Hello, {{customer}}</h1>
      <ul>
        <!-- Ebony and Chiho in a list-->
        <li *ngFor="let customer of customers">{{ customer.value }}</li>
      </ul>
    </div>
  `
})
class AppComponent {
  customers = [{value: 'Ebony'}, {value: 'Chiho'}];
  customer = 'Padma';
}
```

`customer` в [ngFor](https://angular.io/api/common/NgForOf) находится в контексте [<ng-template>](https://angular.io/api/core/ng-template) и поэтому относится к "customer" в массиве `customers`, в данном случае Ebony и Chiho. В этом списке нет Padma, потому что `customer` вне [ngFor](https://angular.io/api/common/NgForOf) находится в другом контексте. И наоборот, `customer` в `<h1>` не включает Ebony или Chiho, потому что контекстом для этого `customer` является класс, а значением класса для `customer` является Padma.

# Наилучшие подходы в части выражений

При использовании шаблон-выражений следуйте следующим рекомендациям:

- **Используйте короткие выражения**.
    
    Используйте имена свойств или вызовы методов, когда это возможно. Храните прикладную и бизнес-логику в компоненте, где она доступна для разработки и тестирования.
    
- **Быстрое выполнение**.
    
    Angular выполняет шаблонные выражения после каждого цикла [обнаружения изменений](https://angular.io/guide/glossary#change-detection). Многие асинхронные действия вызывают циклы обнаружения изменений, такие как выполнение promise, результаты HTTP, события таймера, нажатия клавиш и перемещения мыши.
    
    Выражения должны завершаться быстро, чтобы обеспечить максимальную эффективность работы пользователя, особенно на медленных устройствах. Рассмотрите возможность кэширования значений, если их вычисление требует больших ресурсов.
    
- **Отсутствие видимых побочных эффектов**.
    
    Согласно [однонаправленной модели потока данных Angular](https://angular.io/guide/glossary#unidirectional-data-flow), выражение шаблона не должно изменять никакое состояние приложения, кроме значения целевого свойства. Чтение значения компонента не должно изменять какое-либо другое отображаемое значение. Представление должно быть стабильным в течение одного прохода рендеринга.
    
    <aside>
    💡 **ИДЕМПОТЕНТНЫЕ ВЫРАЖЕНИЯ УМЕНЬШАЮТ ПОБОЧНЫЕ ЭФФЕКТЫ**.
    
    Идемпотентное выражение [idempotent](https://en.wikipedia.org/wiki/Idempotence) не имеет побочных эффектов и улучшает производительность обнаружения изменений в Angular. В терминах Angular, идемпотентное выражение всегда возвращает *совершенно одно и то же*, пока одно из его зависимых значений не изменится.
    
    Зависимые значения не должны меняться в течение одного оборота цикла событий. Если идемпотентное выражение возвращает строку или число, оно возвращает ту же строку или число, если вы вызываете его дважды подряд. Если выражение возвращает объект, включая `массив`, оно возвращает один и тот же объект *ссылка*, если вы вызываете его дважды подряд.
    
    </aside>
    
    > Существует одно исключение из этого поведения, которое относится к [ngFor](https://angular.io/api/common/NgForOf). [ngFor](https://angular.io/api/common/NgForOf) имеет функциональность `trackBy`, которая может работать с изменяющимися значениями в объектах при итерации по ним. Подробности смотрите в [ngFor with trackBy](https://angular.io/guide/built-in-directives#ngfor-with-trackby).
    > 

{ - done - 2021-11-20 }
